use super::types::Price;
use crate::{
    fraction::BigFraction,
    utils::{Fraction, U128, U256},
};

pub(crate) fn price_to_fraction<T>(price: Price<T>) -> Fraction
where
    T: Into<U128> + Copy,
{
    let Price { value, exp } = price;
    let value: U256 = value.into().into();
    let decimal = ten_pow(exp);

    let value_bf = BigFraction::from_num(value);
    let price_bf = value_bf / decimal;
    price_bf
        .try_into()
        .expect("Failed to convert Price stored on BigFraction to Fraction")
}

fn ten_pow(exponent: u32) -> U128 {
    let value: u128 = match exponent {
        30 => 1_000_000_000_000_000_000_000_000_000_000,
        29 => 100_000_000_000_000_000_000_000_000_000,
        28 => 10_000_000_000_000_000_000_000_000_000,
        27 => 1_000_000_000_000_000_000_000_000_000,
        26 => 100_000_000_000_000_000_000_000_000,
        25 => 10_000_000_000_000_000_000_000_000,
        24 => 1_000_000_000_000_000_000_000_000,
        23 => 100_000_000_000_000_000_000_000,
        22 => 10_000_000_000_000_000_000_000,
        21 => 1_000_000_000_000_000_000_000,
        20 => 100_000_000_000_000_000_000,
        19 => 10_000_000_000_000_000_000,
        18 => 1_000_000_000_000_000_000,
        17 => 100_000_000_000_000_000,
        16 => 10_000_000_000_000_000,
        15 => 1_000_000_000_000_000,
        14 => 100_000_000_000_000,
        13 => 10_000_000_000_000,
        12 => 1_000_000_000_000,
        11 => 100_000_000_000,
        10 => 10_000_000_000,
        9 => 1_000_000_000,
        8 => 100_000_000,
        7 => 10_000_000,
        6 => 1_000_000,
        5 => 100_000,
        4 => 10_000,
        3 => 1_000,
        2 => 100,
        1 => 10,
        0 => 1,
        _ => panic!("no support for exponent: {exponent}"),
    };

    U128::from(value)
}
